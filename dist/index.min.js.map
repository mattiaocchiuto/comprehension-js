{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/index.min.js","webpack:///webpack/bootstrap c303406e320f4039e5eb","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_typeof","Symbol","iterator","obj","constructor","_isInputSet","test","indexOf","_parseIfNum","val","isNaN","parseInt","trim","completeArray","arrayString","interval","TypeError","PATTERNS","extract","split","reduce","acc","push","_ret","elems","firstElem","lastElem","firstElemParams","v","Array","fill","valToAdd","result","undefined","formatComprehensions","outputExpression","otherArgs","transformationFunction","input","isArray","results","scope","map","predicatesCondition","varName","predicates","predicate","eval","inputSet","rightSide","shift","Error","el","inputSetParams","inputSetFormatted","comprehensions","expression","replace","expressionParams","generalStructure","regExp","outputString","splittingString","scopedVar","arrayStringToFill","testConfigurationName","testString","extractConfigurationName","extractString","extractConfiguration","replacedString"],"mappings":"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","file":"dist/index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Comprehensions\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Comprehensions\"] = factory();\n\telse\n\t\troot[\"Comprehensions\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Comprehensions\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Comprehensions\"] = factory();\n\telse\n\t\troot[\"Comprehensions\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tmodule.exports = function () {\n\t    var PATTERNS = {\n\t        generalStructure: {\n\t            regExp: /\\[(.*)\\|((.*)(,?).*)\\]/,\n\t            outputString: '$1||$2||$3',\n\t            splittingString: '||'\n\t        },\n\t        scopedVar: {\n\t            regExp: /(\\w)<-(.*)/,\n\t            outputString: '$1'\n\t        },\n\t        inputSet: {\n\t            regExp: /(.*)<-\\[(.*)\\]/,\n\t            outputString: '$1||$2',\n\t            splittingString: '||'\n\t        },\n\t        arrayString: {\n\t            regExp: /\\[(.*)\\]/,\n\t            outputString: '$1'\n\t        },\n\t        arrayStringToFill: {\n\t            regExp: /(.*)\\.\\.(.*)/,\n\t            outputString: '$1||$2',\n\t            splittingString: '||'\n\t        },\n\t        test: function test(testConfigurationName, testString) {\n\t            return this[testConfigurationName].regExp.test(testString);\n\t        },\n\t        extract: function extract(extractConfigurationName, extractString) {\n\t            var extractConfiguration = this[extractConfigurationName];\n\t            var regExp = extractConfiguration.regExp;\n\t            var outputString = extractConfiguration.outputString;\n\t            var splittingString = extractConfiguration.splittingString;\n\t\n\t            var replacedString = extractString.replace(regExp, outputString);\n\t\n\t            return splittingString ? replacedString.split(splittingString) : replacedString;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * @param {String} - test\n\t     * @return {Boolean}\n\t     */\n\t    function _isInputSet(test) {\n\t        return test.indexOf('<-') != -1;\n\t    }\n\t\n\t    /**\n\t     * @private\n\t     * @param {Number|String}\n\t     * @param {Number|String} \n\t     */\n\t    function _parseIfNum(val) {\n\t        return !isNaN(parseInt(val)) ? parseInt(val) : val.trim();\n\t    }\n\t\n\t    // Formatta l'array da una scrittura [1..5] a [1,2,3,4,5]\n\t    // per ora assumiamo array numerici\n\t    function completeArray(arrayString) {\n\t        var interval = 1;\n\t\n\t        if (typeof arrayString != 'string') {\n\t            throw new TypeError('The \"arrayString\" parameter has to be a string.');\n\t        }\n\t\n\t        if (PATTERNS.test('arrayString', arrayString)) {\n\t            arrayString = PATTERNS.extract('arrayString', arrayString);\n\t        }\n\t\n\t        if (PATTERNS.test('arrayStringToFill', arrayString)) {\n\t            var _ret = function () {\n\t                var elems = PATTERNS.extract('arrayStringToFill', arrayString);\n\t                var firstElem = void 0;\n\t                var lastElem = void 0;\n\t\n\t                if (elems[0].indexOf(',') != -1) {\n\t                    var firstElemParams = elems[0].split(',');\n\t\n\t                    interval = _parseIfNum(firstElemParams[1]) - _parseIfNum(firstElemParams[0]);\n\t                    firstElem = _parseIfNum(firstElemParams[0]);\n\t                }\n\t\n\t                firstElem = _parseIfNum(elems[0]);\n\t                lastElem = _parseIfNum(elems[1]);\n\t\n\t                if (lastElem < firstElem) {\n\t                    return {\n\t                        v: []\n\t                    };\n\t                }\n\t\n\t                return {\n\t                    v: Array(lastElem).fill(firstElem).reduce(function (acc, val) {\n\t                        var valToAdd = !acc.lastElem ? val : acc.lastElem + interval;\n\t\n\t                        if (valToAdd <= lastElem) {\n\t                            acc.result.push(valToAdd);\n\t                            acc.lastElem = valToAdd;\n\t                        }\n\t\n\t                        return acc;\n\t                    }, { result: [], lastElem: undefined }).result\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t            return arrayString.split(',').reduce(function (acc, val) {\n\t                acc.push(_parseIfNum(val));\n\t\n\t                return acc;\n\t            }, []);\n\t        }\n\t    }\n\t\n\t    function formatComprehensions(outputExpression, otherArgs) {\n\t        var inputSet = void 0;\n\t        var varName = void 0;\n\t        var rightSide = otherArgs.split(',');\n\t        var predicates = []; // Filtri da applicare.\n\t\n\t        inputSet = rightSide.shift();\n\t\n\t        // Check that an input set has been passed.\n\t        if (!_isInputSet(inputSet)) {\n\t            throw new Error('You have to specify an input set.');\n\t        }\n\t\n\t        // Get the varName.\n\t        varName = PATTERNS.extract('scopedVar', inputSet);\n\t\n\t        // Fill the predicates array.\n\t        rightSide.map(function (el) {\n\t            predicates.push(el);\n\t        });\n\t\n\t        /**\n\t         * It take an input array and apply the output-function at the\n\t         * elements respecting the filter functions.\n\t         * @param {Array} - input\n\t         * @return {Array}\n\t         */\n\t        function transformationFunction(input) {\n\t            if (!Array.isArray(input)) {\n\t                throw new TypeError('The input value has to be an Array');\n\t            }\n\t\n\t            var results = [];\n\t            var scope = '';\n\t\n\t            input.map(function (val) {\n\t                var predicatesCondition = false;\n\t\n\t                scope = 'var ' + varName + ' = ' + val + ';';\n\t\n\t                predicatesCondition = predicates.reduce(function (acc, predicate) {\n\t                    return acc && eval(scope + ' ' + predicate + ';');\n\t                }, true);\n\t\n\t                if (predicatesCondition) {\n\t                    results.push(eval(scope + ' ' + outputExpression + ';'));\n\t                }\n\t            });\n\t\n\t            return results;\n\t        }\n\t\n\t        if (PATTERNS.test('inputSet', inputSet)) {\n\t            var inputSetParams = PATTERNS.extract('inputSet', inputSet);\n\t            var inputSetFormatted = completeArray(inputSetParams[1]);\n\t\n\t            return transformationFunction(inputSetFormatted);\n\t        } else {\n\t            return transformationFunction;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {String} expression\n\t     * @return {Function}\n\t     */\n\t    function comprehensions(expression) {\n\t        expression = expression.replace(/ +/g, '');\n\t\n\t        if (!PATTERNS.test('generalStructure', expression)) {\n\t            throw new Error('The input spec does not match any list comprehensions pattern');\n\t        }\n\t\n\t        var expressionParams = PATTERNS.extract('generalStructure', expression);\n\t\n\t        return formatComprehensions(expressionParams[0], expressionParams[1]);\n\t    }\n\t\n\t    return {\n\t        comprehensions: comprehensions,\n\t        completeArray: completeArray\n\t    };\n\t}();\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/index.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c303406e320f4039e5eb\n **/","'use strict';\n\nmodule.exports = (function () {\n    let PATTERNS = {\n        generalStructure: {\n            regExp: /\\[(.*)\\|((.*)(,?).*)\\]/,\n            outputString: '$1||$2||$3',\n            splittingString: '||'\n        },\n        scopedVar: {\n            regExp: /(\\w)<-(.*)/,\n            outputString: '$1'\n        },\n        inputSet: {\n            regExp: /(.*)<-\\[(.*)\\]/,\n            outputString: '$1||$2',\n            splittingString: '||'\n        },\n        arrayString: {\n            regExp: /\\[(.*)\\]/, \n            outputString: '$1'\n        },\n        arrayStringToFill: {\n            regExp: /(.*)\\.\\.(.*)/,\n            outputString: '$1||$2',\n            splittingString: '||'\n        },\n        test: function (testConfigurationName, testString) {\n            return this[testConfigurationName].regExp.test(testString);\n        },\n        extract: function (extractConfigurationName, extractString) {\n            let extractConfiguration = this[extractConfigurationName];\n            let regExp = extractConfiguration.regExp;\n            let outputString = extractConfiguration.outputString;\n            let splittingString = extractConfiguration.splittingString;\n\n            let replacedString = extractString.replace(regExp, outputString);\n\n            return splittingString ? replacedString.split(splittingString) : replacedString;\n        }\n    };\n\n    /**\n     * @private\n     * @param {String} - test\n     * @return {Boolean}\n     */\n    function _isInputSet(test) {\n        return test.indexOf('<-') != -1;\n    }\n\n    /**\n     * @private\n     * @param {Number|String}\n     * @param {Number|String} \n     */\n    function _parseIfNum(val) {\n        return !isNaN(parseInt(val)) ? parseInt(val) : val.trim();\n    }\n\n    // Formatta l'array da una scrittura [1..5] a [1,2,3,4,5]\n    // per ora assumiamo array numerici\n    function completeArray(arrayString) {\n        let interval = 1;\n\n        if (typeof arrayString != 'string') {\n            throw new TypeError('The \"arrayString\" parameter has to be a string.');\n        }\n\n        if (PATTERNS.test('arrayString', arrayString)) {\n            arrayString = PATTERNS.extract('arrayString', arrayString);\n        }\n\n        if (PATTERNS.test('arrayStringToFill', arrayString)) {\n            let elems = PATTERNS.extract('arrayStringToFill', arrayString)\n            let firstElem;\n            let lastElem;\n\n            if (elems[0].indexOf(',') != -1) {\n                let firstElemParams = elems[0].split(',');\n\n                interval = _parseIfNum(firstElemParams[1]) - _parseIfNum(firstElemParams[0]);\n                firstElem = _parseIfNum(firstElemParams[0]);\n            }\n\n            firstElem = _parseIfNum(elems[0]);\n            lastElem = _parseIfNum(elems[1]);\n\n            if (lastElem < firstElem) {\n                return [];\n            }\n\n            return Array(lastElem).fill(firstElem).reduce(function (acc, val) {\n                let valToAdd = !acc.lastElem ? val : acc.lastElem + interval;\n\n                if (valToAdd <= lastElem) {\n                    acc.result.push(valToAdd);\n                    acc.lastElem = valToAdd;\n                }\n\n                return acc;\n            }, { result: [], lastElem: undefined }).result;\n        } else {\n            return arrayString.split(',').reduce(function (acc, val) {\n                acc.push(_parseIfNum(val));\n\n                return acc;\n            }, []);\n        }\n    }\n\n    function formatComprehensions(outputExpression, otherArgs) {\n        let inputSet;\n        let varName;\n        let rightSide = otherArgs.split(',');\n        let predicates = []; // Filtri da applicare.\n\n        inputSet = rightSide.shift();\n\n        // Check that an input set has been passed.\n        if (!_isInputSet(inputSet)) {\n            throw new Error('You have to specify an input set.');\n        }\n\n        // Get the varName.\n        varName = PATTERNS.extract('scopedVar', inputSet);\n\n        // Fill the predicates array.\n        rightSide.map((el) => {\n            predicates.push(el);\n        });\n\n        /**\n         * It take an input array and apply the output-function at the\n         * elements respecting the filter functions.\n         * @param {Array} - input\n         * @return {Array}\n         */\n        function transformationFunction(input) {\n            if (!Array.isArray(input)) {\n                throw new TypeError('The input value has to be an Array')\n            }\n\n            let results = [];\n            let scope = '';\n\n            input.map((val) => {\n                let predicatesCondition = false;\n\n                scope = `var ${varName} = ${val};`;\n\n                predicatesCondition = predicates.reduce((acc, predicate) => {\n                    return acc && eval(`${scope} ${predicate};`);\n                }, true);\n\n                if (predicatesCondition) {\n                    results.push(eval(`${scope} ${outputExpression};`));\n                }\n            });\n\n            return results;\n        }\n\n        if (PATTERNS.test('inputSet', inputSet)) {\n            let inputSetParams = PATTERNS.extract('inputSet', inputSet);\n            let inputSetFormatted = completeArray(inputSetParams[1]);\n            \n            return transformationFunction(inputSetFormatted);\n        } else {\n            return transformationFunction;\n        }\n    }\n\n    /**\n     * @param {String} expression\n     * @return {Function}\n     */\n    function comprehensions(expression) {\n        expression = expression.replace(/ +/g, '');\n\n        if (!PATTERNS.test('generalStructure', expression)) {\n            throw new Error('The input spec does not match any list comprehensions pattern');\n        }\n\n        let expressionParams = PATTERNS.extract('generalStructure', expression);\n\n        return formatComprehensions(expressionParams[0], expressionParams[1]);\n    }\n\n    return {\n        comprehensions,\n        completeArray\n    };\n})();\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/"],"sourceRoot":""}